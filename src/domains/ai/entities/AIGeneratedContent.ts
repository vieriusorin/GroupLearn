/**
 * AI Generated Content Entity
 *
 * Represents content (flashcards) that has been generated by AI from various sources
 * like PDFs, URLs, text, or audio. Tracks the generation process, approval status,
 * and metadata about the AI model and costs.
 */

export interface FlashcardDraft {
  question: string;
  answer: string;
  difficulty: "easy" | "medium" | "hard";
  category?: string;
  hints?: string;
}

export interface AIGeneratedContentProps {
  id?: number;
  sourceType: "pdf" | "url" | "text" | "audio";
  sourceUrl?: string;
  sourceContent?: string;
  extractedText?: string;
  generatedCards: FlashcardDraft[];
  status: "pending" | "processing" | "completed" | "failed";
  userId: string;
  modelUsed?: string;
  tokensUsed?: number;
  estimatedCost?: number;
  errorMessage?: string;
  approvedCount: number;
  rejectedCount: number;
  createdAt: Date;
  completedAt?: Date;
}

export class AIGeneratedContent {
  private readonly props: AIGeneratedContentProps;

  constructor(props: AIGeneratedContentProps) {
    this.props = { ...props };
  }

  get id(): number | undefined {
    return this.props.id;
  }

  get sourceType(): "pdf" | "url" | "text" | "audio" {
    return this.props.sourceType;
  }

  get sourceUrl(): string | undefined {
    return this.props.sourceUrl;
  }

  get sourceContent(): string | undefined {
    return this.props.sourceContent;
  }

  get extractedText(): string | undefined {
    return this.props.extractedText;
  }

  get generatedCards(): FlashcardDraft[] {
    return [...this.props.generatedCards];
  }

  get status(): "pending" | "processing" | "completed" | "failed" {
    return this.props.status;
  }

  get userId(): string {
    return this.props.userId;
  }

  get modelUsed(): string | undefined {
    return this.props.modelUsed;
  }

  get tokensUsed(): number | undefined {
    return this.props.tokensUsed;
  }

  get estimatedCost(): number | undefined {
    return this.props.estimatedCost;
  }

  get errorMessage(): string | undefined {
    return this.props.errorMessage;
  }

  get approvedCount(): number {
    return this.props.approvedCount;
  }

  get rejectedCount(): number {
    return this.props.rejectedCount;
  }

  get createdAt(): Date {
    return this.props.createdAt;
  }

  get completedAt(): Date | undefined {
    return this.props.completedAt;
  }

  /**
   * Mark as processing
   */
  markAsProcessing(): AIGeneratedContent {
    return new AIGeneratedContent({
      ...this.props,
      status: "processing",
    });
  }

  /**
   * Mark as completed with generated cards
   */
  markAsCompleted(
    cards: FlashcardDraft[],
    modelUsed: string,
    tokensUsed: number,
    estimatedCost: number
  ): AIGeneratedContent {
    return new AIGeneratedContent({
      ...this.props,
      status: "completed",
      generatedCards: cards,
      modelUsed,
      tokensUsed,
      estimatedCost,
      completedAt: new Date(),
    });
  }

  /**
   * Mark as failed with error message
   */
  markAsFailed(errorMessage: string): AIGeneratedContent {
    return new AIGeneratedContent({
      ...this.props,
      status: "failed",
      errorMessage,
      completedAt: new Date(),
    });
  }

  /**
   * Update approval counts
   */
  updateApprovalCounts(approvedCount: number, rejectedCount: number): AIGeneratedContent {
    return new AIGeneratedContent({
      ...this.props,
      approvedCount,
      rejectedCount,
    });
  }

  /**
   * Check if generation is complete
   */
  isComplete(): boolean {
    return this.props.status === "completed" || this.props.status === "failed";
  }

  /**
   * Check if all cards have been reviewed
   */
  isFullyReviewed(): boolean {
    return this.props.approvedCount + this.props.rejectedCount === this.props.generatedCards.length;
  }

  /**
   * Get approval rate
   */
  getApprovalRate(): number {
    const total = this.props.approvedCount + this.props.rejectedCount;
    return total === 0 ? 0 : (this.props.approvedCount / total) * 100;
  }

  /**
   * Convert to plain object for persistence
   */
  toObject(): AIGeneratedContentProps {
    return { ...this.props };
  }
}
